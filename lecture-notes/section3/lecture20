---
UNSIGNED INTEGERS
---

-> Each bit can store 2 values → 0 or 1.

-> 8 bits can store 2^8, 0 to 255 combinations of 0 to 1, each representing a different number.

-> 32 bits can store 2^32, 0 to 4,294,967,295, each representing a different number.

---
SIGNED INTEGERS
---

-> MSB (1)=minus(-), MSB(0)=plus(+).

-> can store 2^7, with the last bit being reserved for sign.

---
binary numbers used for signed integers (in nearly all modern computers and programming languages like C, C++, Python, etc.) use the two’s complement system to represent negative numbers.
---

-> All modern architectures — Intel, AMD, ARM, MIPS, RISC-V, etc. — use two’s complement exclusively for signed integers.

---
-> We make datatypes public, for example uint public myBool, to be able to use the getter function provided by solidity.
---

-> If we explicitly assign a default value to a datatype, for example false for bool, or 0 for int, It is going to cost extra gas. 

-> uint is an alias for uint256, which can store 2^256-1 long integers.

---
Solidity also allows unsigned integers in steps of 8 bits: 2^8, 2^16, 2^24 ...
---

-> Pervious versions of solidity(before 0.8.14) reverted back to 0, after exceeding its max, this however stays till max.

-> For example when uint8, tries to increment to 255, you should see an error, and its value stays at 255.

---
UNSIGNED INTEGER
---

-> range for signed int is 2^127, negative side has one more number, since modern systems use two's complement, which allows 11111111 to be -1 -> 2^127-1, not 128-1, since one bit is reserved for sign
